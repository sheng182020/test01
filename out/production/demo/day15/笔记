8.25-线程：
并发：指两个或多个事件在同一个时间段内发生。（一个cpu上快速交替运行）
并行：指两个或多个事件在同一时刻发生（同时发生）。（多个cpu上运行）
注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同
理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个
线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为
线程调度。

进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；
    进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。
线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。
    一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。
简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程

线程调度:
    分时调度
        所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。
    抢占式调度
        优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。
            设置线程的优先级
            抢占式调度详解

Java使用 java.lang.Thread 类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。
Java中通过继承Thread类来创建并启动多线程的步骤如下：
1. 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。
2. 创建Thread子类的实例，即创建了线程对象
3. 调用线程对象的start()方法来启动该线程

多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。
当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。

Thread类构造方法：
       public Thread() :分配一个新的线程对象。
       public Thread(String name) :分配一个指定名字的新的线程对象。
       public Thread(Runnable target) :分配一个带有指定目标新的线程对象。
       public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。

常用方法：
public String getName() :获取当前线程名称。
public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。
public void run() :此线程要执行的任务在此处定义代码。
public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。
public static Thread currentThread() :返回对当前正在执行的线程对象的引用。

（start()启动线程，线程调用run()执行线程体，run()是线程的执行体，开启线程只能使用start（），不能用run()）
 start（）方法让一个线程进入就绪队列等待分配cpu，分到cpu后才调用实现的run()方法。
    调用线程的start方法是创建了新的线程，在新的线程中执行。
    调用线程的run方法是在主线程中执行该方法，和调用普通方法一样，


创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式

采用 java.lang.Runnable
步骤如下：
1. 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
2. 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正
的线程对象。
3. 调用线程对象的start()方法来启动线程。

通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程代码都在run方法里面。
Thread类实际上也是实现了Runnable接口的类。
在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。
实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。

tips:Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。

Thread和Runnable的区别
如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。
总结：
实现Runnable接口比继承Thread类所具有的优势：
1. 适合多个相同的程序代码的线程去共享同一个资源。
2. 可以避免java中的单继承的局限性。
3. 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。
4. 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。

扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。

使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。

线程的睡眠
public static void sleep(long millis) ：让当前线程睡眠指定的毫秒数

线程加入
多条线程时，当指定线程调用join方法时，线程执行权交给该线程，并且当前线程必须等该线程执行完毕之后才会执行但有可能被其他线程抢去CPU执行权.
public final void join() ：让线程在当前线程优先执行,直至t线程执行完毕时,再执行当前线程.
public final void join(long millis) ：让线程执行millis毫秒,再执行其他线程

守护线程
当用户线程(非守护线程)执行完毕时，守护线程也会停止执行但由于CPU运行速度太快，当用户线程执行完毕时，将信息传递给守护线程，会有点时间差，而这些时间差会导致还会执行一点守护线程不管开启多少个线程(用户线程),守护线程总是随着第一个用户线程的停止而停止
public final void setDaemon(boolean on) ：设置线程是否为守护线程

线程优先级
public final void setPriority(int newPriority) ：设置线程的优先级，线程优先级默认为5 最高为10最低为1，如果不在这个范围之内则会抛出.不合法参数异常(IllegalArgumentException)线程优先级高的,更容易让线程在就绪状态中抢到线程执行权,变成执行状态.但是 线程优先级高 也不一定执行的就多.也有可能优先级低的优先执行完毕

线程礼让
public static void yield() ：线程礼让，告知当前线程可以将执行权礼让给其他线程，礼让给优先级相对高一点的线程，但仅仅是一种告知,并不是强制将执行权转让给其他线程.也有可能下次的执行权还在原线程这里。如果想让原线程强制让出执行权 可以使用join()方法

线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写
操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，
否则的话就可能影响线程安全。

同步代码块： synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。
格式：
    synchronized(同步锁){
    需要同步操作的代码
    }
同步锁:
对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.
    1. 锁对象 可以是任意类型。
    2. 多个线程对象 要使用同一把锁。
注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。

同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。
格式：
    public synchronized void method(){
    可能会产生线程安全问题的代码
    }
同步锁是谁?
对于非static方法,同步锁就是this。
对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。

Lock锁
java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。
Lock锁也称同步锁，加锁与释放锁方法化了，如下：
public void lock() :加同步锁。
public void unlock() :释放同步锁。

线程的等待
public final void wait() ：让当前线程进入等待状态(并不是当前线程对象来调用,而是当前锁对象来调用) 调用wait()之后释放当前锁,并且让当前锁对象中对应的线程阻塞.
public final void notify() ：随机唤醒一条此锁对象对应线程中的一条.notify()也是锁对象来调用,并不是当前线程对象调用

因为wait需要释放锁，所以必须在synchronized中使用，没有锁时使用会抛出IllegalMonitorStateException（正在等待的对象没有锁）

wait():方法必须配合同步锁使用,同步锁中的对象是谁 那么就用谁来调用wait方法 必须要是多个线程执行多个任务的时候才能体现出等待线程和唤醒线程的作用
调用wait和notify方法需要注意的细节
1. wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。
2. wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。
3. wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。

8.25-线程状态：
sleep和wait方法的区别？
sleep():必须传入睡眠的时间毫秒值,和毫秒值加纳秒值
wait():可以不用指定时间,如果指定时间代表线程不会立马等待,而是指定时间过后再等待

sleep():在休眠指定时间后自动醒来,并且休眠时间不释放锁
wait():等待过程中不会自动醒来,而是调用notify()方法来唤醒,并且调用时里面释放锁

wait()方法必须是锁对象来调用，而且必须是在同步代码块中执行，否则会出现 IllegalMonitorStateException 异 常

线程状态：                    导致状态发生条件：
NEW(新建)                   线程刚被创建，但是并未启动。还没调用start方法。
Runnable(可运行)             线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。
Blocked(锁阻塞)              当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。
Waiting(无限等待)             一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。
TimedWaiting(计时等待)        同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。
Teminated(被终止)             因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。

notify()：唤醒在当前锁对象中随机的一条线程
notifyAll()：唤醒当前锁对象对应的所有线程(效率低)