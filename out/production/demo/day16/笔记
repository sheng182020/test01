8.26-线程池：
线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作， 无需反复创建线程而消耗过多资源。

线程池的工作机制:
       在线程池的编程模式下，任务是提交给整个线程池，而不是直接提交给某个线程，线程池在拿到任务后，就在内部寻找是否有空闲的线程，如果有，则将任务交给某个空闲的线程。
       一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。

线程池的流程
    1、判断核心线程池是否已满，没满则创建一个新的工作线程来执行任务。已满则。
    2、判断任务队列是否已满，没满则将新提交的任务添加在工作队列，已满则。
    3、判断整个线程池是否已满，没满则创建一个新的工作线程来执行任务，已满则执行饱和策略。

    （1、判断线程池中当前线程数是否大于核心线程数，如果小于，在创建一个新的线程来执行任务，如果大于则
    2、判断任务队列是否已满，没满则将新提交的任务添加在工作队列，已满则。
    3、判断线程池中当前线程数是否大于最大线程数，如果小于，则创建一个新的线程来执行任务，如果大于，则执行饱和策略。）

2. 线程池的优点
合理利用线程池能够带来三个好处：
1. 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
2. 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
3. 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内 存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。

其实Executors的4个功能线程有如下弊端：
FixedThreadPool和SingleThreadExecutor：主要问题是堆积的请求处理队列均采用LinkedBlockingQueue，可能会耗费非常大的内存，甚至OOM。
CachedThreadPool和ScheduledThreadPool：主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。

Executors类中有个创建线程池的方法如下：
public static ExecutorService newFixedThreadPool(int nThreads) ：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)

获取到了一个线程池ExecutorService 对象，在这里定义了一个使用线程池对象的方法如下：
public Future<?> submit(Runnable task) :获取线程池中的某一个线程对象，并执行

Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。

使用线程池中线程对象的步骤：
1. 创建线程池对象。
2. 创建Runnable接口子类对象。(task)
3. 提交Runnable接口子类对象。(take task)
4. 关闭线程池(一般不做)。

定长线程池（FixedThreadPool）
    特点：只有核心线程，线程数量固定，执行完立即回收，任务队列为链表结构的有界队列。
    应用场景：控制线程最大并发数
定时线程池（ScheduledThreadPool ）
    特点：核心线程数量固定，非核心线程数量无限，执行完闲置10ms后回收，任务队列为延时阻塞队列。
    应用场景：执行定时或周期性的任务
可缓存线程池（CachedThreadPool）
    特点：无核心线程，非核心线程数量无限，执行完闲置60s后回收，任务队列为不存储元素的阻塞队列。
    应用场景：执行大量、耗时少的任务
单线程化线程池（SingleThreadExecutor）
    特点：只有1个核心线程，无非核心线程，执行完立即回收，任务队列为链表结构的有界队列。
    应用场景：不适合并发但可能引起IO阻塞性及影响UI线程响应的操作，如数据库操作、文件操作等。
